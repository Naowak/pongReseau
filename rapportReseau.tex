\documentclass[a4paper, 12pt]{scrreprt}


\usepackage[francais]{babel}
\usepackage[utf8]{inputenc}
\usepackage{url}
\usepackage{graphicx}
\usepackage{tikz}

\pagestyle{plain}

\title{Rapport de Projet de programmation 2}
\subtitle{Creation d'un Pong en Réseau}
\author{Par \bsc{Bendi-Ouis} Yannis \\
Et \bsc{Rade-Morzadec} Mathis \\
Pour L'Université de Bordeaux}
\date{\today}

\begin{document}

\maketitle

\section*{Introduction}
\paragraph{}
Dans notre pong, chaque joueur contrôle deux raquettes:
- une principale, d'une largeur semblable à celle d'un Pong traditionnel
- une secondaire, plus petite et plus proche du centre.
\\\includegraphics[scale=0.56]{terrain.png}
\\La raquette secondaire est intelligente: elle ne renvoie pas la balle vers son propre camp si elle la frappe par derrière (la raquette représente un joueur, non un mur)
\paragraph{}
Le joueur se trouve toujours à gauche de l'écran (le jeu est représenté en miroir sur chaque machine), il manipule la raquette principae avec Z et S, et la secondaire avec les flèches directionelles haut et bas.
\paragraph{}
Il suffit de frapper une balle avec une raquette pour la renvoyer, il est néanmoins possible de mettre un effet dans la balle en déplaçant la raquette durant la frappe:
\\- Si la raquette va dans le même sens que la balle, cela va rétrécir l'angle de rebond de la balle.
\\- Si la raquette va dans le sens opposé à celui de la balle, l'angle de rebond sera alors amplifié.

\paragraph{}
Lorsque la balle sort d'un côté de l'écran , le joueur opposé marque un point.
\\La balle se pose ensuite devant le joueur perdant et repart après 2 secondes de pause.
\paragraph{}
Le jeu se déroule en 8 points gagnants.
\\On notera aussi la présence de son lors de la frappe de la balle et lors d'une victoire/défaite.


\section*{Le code}
\paragraph{}
À partir du code fournit de base, nous avons en quelques heures (~5h) réussi à mettre le jeu en réseau, et à transformer un code très «impératif» en un code plus «objet».
Les premières difficultées arrivent alors:
\\- Impossible d'afficher des images de vitoire et de défaites.
\\- Après plusieurs échanges, les jeux se désyncronisaient sur les deux machines.
\subsubsection*{LE BUG DES IMAGES DE LA MORT QUI TUE}
\paragraph{}
Alors qu'à chaque frame nous affichions avec succès toutes les images (balle, raquettes, tableau des scores), les images de fin (victoire/défaite) refusaient de s'afficher à la dernière image.
\\Si l'on ne pouvait pas afficher victoire.png à la fin, on réussissait néanmoins à afficher ball.png à la fin, ou tout autres images utilisées ailleur dans le jeu.
\\Nous avons donc essayé d'afficher victoire.png autre part qu'à la fin (en fond d'écran par exemple), et là, l'affichage fonctionnait.
\\Nous étions capables d'afficher certaines images mais pas toutes, et pourtant nos images étaient bonnes puisque l'on pouvait les afficher en cours de jeu.
\paragraph{}
S'en suit donc un débuggage intensif sur plusieurs jours, on estime un total de 7h30 de travail chacun sur ce seul bug. 7h30 où nous avons tenté tout et n'importe quoi : changer le nom des variables, des fichiers, réduire la qualité des images, les afficher en plus petit ... Certain test nous ont même poussés à croire que les images ne s'affichaient que si leur affichage était ordonné en dehors d'un «if» ...
\\Partant fouiller dans l'arbre d'héritage de JPanel (dont notre Pong hérite) pour comprendre quels effets complexes pouvaient avoir les fonctions que l'on redéfinissait, certaines agissaient différement avec les images lourdes et les images légères. Mais ça ne nous aida pas à résoudre notre problème.
\\Et c'est seulement après ces nombreuses heures érintantes que nous finisson par trouver quelque chose:
\\Une image s'affiche à la fin seulement si elle à déjà été affichée plus tôt dans le jeu. Pourquoi?... Aucune idée, mais ça ce passait comme ça.
\paragraph{}
Solution : Mettre du scotch, c'est à dire : A chaque frame on affiche les images de victoire/défaite, puis on peint tout l'écran en gris, puis on affiche les raquettes et la balle.\\
Comme ça à la fin, on affiche l'image de victoire ou de défaite qui a déjà été affichée ... et qui donc ne bug pas.
Nous avons aussi essayé d'afficher deux fois successivement l'image mais sans succès, ou même de l'afficher dans le constructeur de la classe. Mais sans succès non plus.
\subsubsection*{La syncronisation}
\paragraph{}
Pour synchroniser nos machines on établie un protocole simpliste:
À chaque frame le joueur appuie sur une touche (ou sur aucune), donc à chaque frame chaque machine fait:
\\Un write() qui contient la(les) touche(s) sur la(es)quel(s) il appuie.
\\Puis tout de suite, un read() BLOQUANT pour recevoir le write() de son adversaire.
\paragraph{}
Ainsi le poids des données transportés est faible (2 int par frame), les machine sont syncronisée car forcées de s'attendre. La triche est impossible car les seules infos envoyables sont «je monte» ou «je descend», au pire il peut modifier des choses sur sa machine, ce qu'il n'affectera pas l'autre machine et causera une désyncronisation.
Pourtant, des incohérences apparaissent: dans certaines parties, la balle n'est pas au même endoit sur les deux machines.
\paragraph{}
La encore plusieurs heures de debugging pour traquer le bug. En fait, l'erreur était stupide.
\\La fenetre et le jeu font SIZE-PONG pixels de long. Donc le dernier pixel est numéroté SIZE-PONG -1, mais certains de nos calculs faisaient partir la balle du SIZE-PONGieme pixel. Donc il y avait une assymétrie qui s'emplifiait à chaque point. Et qui finalement provoquait de grandes incohérence.
\\Le problème reglé, la syncronisation fonctionne.

\section*{Diagramme des classes}
\paragraph{}
Le diagramme de classe est assez simple. La plupart des classes sont seules : 
\begin{itemize}
\item Sock (qui gère la communication) ;
\item Window (qui affiche a l'ecran et fait un while() qui contient le jeu) qui étend JFrame (librairie java standard)
\item Main
\item Pong (qui contient le jeu en soit) qui étend JPanel et implémente KeyListener (librairie Java standard)
\item Sound (qui fait les sons) qui étend Thread (librairie Java standard).
\end{itemize}
\newpage
\paragraph{}
Le seul arbre d'héritage est celui des «PongObjects» :
\\\\\begin{tikzpicture}[sibling distance=10em,
  every node/.style = {shape=rectangle, rounded corners,
    draw, align=center,
    top color=white, bottom color=blue!20}]]

  \node {PongObjectInterface}
    child { node {PongObjectAbstract}
      child { node {Ball}}
      child { node {Racket}
        child { node {SmallRacket}}}};
\end{tikzpicture}

\section*{Conclusion}
Bref, le programme fonctionne, il est assez sobre, et assez rapide entre deux machines du CREMI, mais lag fortement sur nos réseaux domestiques.\\
Le jeu est simple à comprendre, sans fioritures. Mais il y peut y avoir une «courbe de progression» avec la gestion des effets.\\
La triche n'est pas possible, et les données échangées sont légères.
Et en plus, il y des pandas roux.

\section*{Bibliographie}
\begin{itemize}
\item www.clipartpanda.com (imageWin.png / imageLose.png)
\item www.youtube.com (les sons)
\item openclipart.org (ball.png)
\end{itemize}

\end{document}